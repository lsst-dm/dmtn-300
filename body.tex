\section{Motivation}

The Rubin Data Butler \citep{2022SPIE12189E..11J} consists of a metadata registry and a file datastore.
The registry contains sufficient information to construct ObsCore records.
Previously it was possible to provide an ObsCore table using two methods: export the records as CSV or Parquet files; provide live syncing to an ObsCore table using hooks in the registry backend.

Both these approaches have been implemented by us and are the only way we have to provide an ObsTAP service. However, there are downsides.
Whilst static export works fine for formal data releases where it can be integrated into our high performance Qserv database, it is not suitable for evolving datasets such at that from the nightly prompt products.
“Live” ObsCore does work but requires that the deployment has pgsphere available. Also, if the configuration changes (something that can happen a lot during early operations) the entire table needs to be rebuilt.

These two issues suggested that there would be a benefit from providing a simpler, yet standardized, query layer directly on top of the Butler. The IVOA's Simple Image Access version 2 \citep[SIAv2;][]{2015ivoa.spec.1223D} was the obvious choice for this. Interfacing directly to the Butler provides much more flexibility since configuration changes can be picked up with a simple redeployment of the service and it can work immediately with any Butler repository.

\section{Implementation}

\articlefigure{P920_f1.eps}{fig:arch}{Architecture diagram showing how the SIAv2 service interfaces with the Butler.}

We used a layered approach to implementation.
The service itself \citep{SQR-095} is written using Rubin's standard internal development platform Phalanx.
This provides us with our standard auth layer and deployment capabilities.

The service takes the raw SIAv2 parameters and passes them, along with the SIAv2 configuration, to the \texttt{dax\_obscore} library which parses the parameters, converts them to Butler queries, runs the queries, and returns the standarized results as an Astropy VOTable that can be packaged up by the service and returned.
The resulting table schema is defined by a Felis data model for consistency (see talk by Jeremy McCormick).

This approach lets us separate the service from the Butler interface and allows the system to be tested independently with the added bonus that the SIAv2 interface is available from the command-line.

\section{Current Status}

A service has been deployed on the Rubin Science Platform and is ready to be used with commissioning data.
The \texttt{dax\_obscore} package supports the following SIAv2 query parameters at this time:
\texttt{MAXREC},
\texttt{INSTRUMENT},
\texttt{POS},
\texttt{TIME},
\texttt{BAND},
\texttt{EXPTIME},
\texttt{CALIB}.

Butler has native support for region queries.
Support for
\texttt{ID},
\texttt{TARGET},
\texttt{FACILITY},
and \texttt{COLLECTION} are coming soon.

\section{Model Mismatches}

The Butler data model as used by Rubin Observatory does result in some implementation difficulties.

\subsection{Instrument for coadds}

Currently, as defined by the Rubin Science Pipelines team, the Butler registry does not have an instrument associated with co-adds. The instrument is recorded in the datasets and in the collection names but when the pipelines were initially defined it was deemed to be unimportant to include the instrument information in the dataset type definition itself. This causes difficulties in SIAv2 in a Butler repository where LATISS and LSSTCam data are both available since there is no way to know from the query system which is which.

\subsection{Exposure time for co-adds}

Butler does not know anything about derived metadata such as median exposure times for a co-add.

\subsection{Observing dates for co-adds}

Butler does know the observing dates of individual observations but for a co-add this information is lost. In the future when a full Butler provenance system is implemented it may be possible to derive the date range for co-adds but it is not possible at this time.

\subsection{Dataset Types}

Butler makes extensive use of what we call “dataset types” which define each product type in a pipeline. Examples can be \texttt{visit\_image}, \texttt{difference\_image}, and \texttt{deep\_coadd}.
Currently there is no standardized way in SIAv2 for a query to specify these.
We are looking at adding an extension.
